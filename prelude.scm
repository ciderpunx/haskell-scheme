(* First shot at a scheme standard library. Note that comments are in this format *)
(define (id obj)           obj) ; inline comments are also OK
(define (list . xs)        xs) 
(define (not x)            (if x #f #t))
(define (and . lst)        (foldl && #t lst))       
(define (or . lst)         (foldl || #f lst))       
(define (any? pred . lst)  (apply or (map pred lst)))
(define (every? pred . lst) (apply and (map pred lst)))
(define (null? obj)        (if (eqv? obj '()) #t #f))
(define (flip func)        (lambda (arg1 arg2) (func arg2 arg1)))
(define (curry func arg1)  (lambda (arg) (apply func (cons arg1 (list arg)))))
(define (compose f g)      (lambda (arg) (f (apply g arg))))
(define zero?              (curry = 0))
(define positive?          (curry < 0))
(define negative?          (curry > 0))
(define (odd? num)         (= (mod num 2) 1))
(define (even? num)        (= (mod num 2) 0))
(define (foldl func accum lst)
  (if (null? lst)
      accum
      (foldl func (func accum (car lst)) (cdr lst))))
(define fold               foldl)
(define (map  fn lst)
  (if (null? lst)
    '()
    (cons (fn (car lst)) 
          (map fn (cdr lst)))))
(define (sum . lst)        (foldl + 0 lst))
(define (product . lst)    (foldl * 1 lst))
(define (count . lst)      (foldl (λ (x y) (+ x 1)) 0 lst))
(define (length x)         (apply count x))
(define (max l . lst)      (foldl (λ (x y) (if (> x y) x y)) l lst))
(define (min l . lst)      (foldl (λ (x y) (if (< x y) x y)) l lst))
(define (list_last lst)                      
    (if (null? (cdr lst))
      (car lst)
      (list_last (cdr lst))))
(define (last . lst)      (list_last lst))     
(define (vector-copy v)   (if (vector? v) v #()))
(define (list->vector l)  (vector l))
(define (vector->list v)  (as-list v))
(define (vector-length v) 
  (if (vector? v)
    (length (vector->list v)) 
    (display "Non-vector argument to vector-length?")))
(define (displayln m)     (begin 
                            (display m) 
                            (display #\newline)))
(define (assert val expected msg) 
  (if (eq? val expected) 
      #t
      (begin 
        (display "!!!!! Assertion Failed !!!!!!\n")
        (displayln msg)
        (exit))))
(define (string->list s)  (as-list s))
(define (string-length s) 
  (if (string? s) 
    (length (string->list s)) 
    (display "Non-string argument to string-length")))
(define (string-null? s)  (eq? 0 (string-length s)))
